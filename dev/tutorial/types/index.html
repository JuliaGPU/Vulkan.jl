<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vulkan types · Vulkan.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Vulkan.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../intro/">Introduction</a></li><li><span class="tocitem">About</span><ul><li><a class="tocitem" href="../../about/motivations/">Motivations</a></li><li><a class="tocitem" href="../../about/interfacing/">Interfacing with the C API</a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Vulkan types</a><ul class="internal"><li><a class="tocitem" href="#Handles"><span>Handles</span></a></li><li><a class="tocitem" href="#Structures"><span>Structures</span></a></li><li><a class="tocitem" href="#Bitmask-flags"><span>Bitmask flags</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Vulkan functions</a></li><li><a class="tocitem" href="../error_handling/">Error handling</a></li><li><a class="tocitem" href="../resource_management/">Resource management</a></li><li><a class="tocitem" href="../dispatch/">Dispatch</a></li><li><a class="tocitem" href="../indepth/">In-depth tutorial</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../howto/preferences/">Setting preferences</a></li><li><a class="tocitem" href="../../howto/debugging/">Debugging</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../utility/">Utility</a></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../dev/overview/">Overview</a></li><li><a class="tocitem" href="../../dev/spec/">Vulkan specification</a></li><li><a class="tocitem" href="../../dev/gen/">Generator</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Vulkan types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vulkan types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGPU/Vulkan.jl/blob/master/docs/src/tutorial/types.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Vulkan-types"><a class="docs-heading-anchor" href="#Vulkan-types">Vulkan types</a><a id="Vulkan-types-1"></a><a class="docs-heading-anchor-permalink" href="#Vulkan-types" title="Permalink"></a></h1><p>The API possesses a few data structures that exhibit a different behavior. We list all of these here along with their properties and features that we hope will free the developer of many patterns and obligations of the Vulkan API.</p><h2 id="Handles"><a class="docs-heading-anchor" href="#Handles">Handles</a><a id="Handles-1"></a><a class="docs-heading-anchor-permalink" href="#Handles" title="Permalink"></a></h2><p>Handles are opaque pointers to internal Vulkan objects. Almost every handle must be created and destroyed with API commands. Some handles have a parent handle (see <a href="#Parent-handle-access">Parent handle access</a> for navigating through the resulting handle hierarchy), which <em>must not</em> be destroyed before its children. For this we provide wrappers around creation functions with an automatic finalization feature (see <a href="#Automatic-finalization">Automatic finalization</a>) that uses a simple reference couting system. This alleviates the burden of tracking when a handle can be freed and freeing it, in conformance with the Vulkan specification.</p><p>Most handles are typically created with a <code>*CreateInfo</code> or <code>*AllocateInfo</code> structure, that packs creation parameters to be provided to the API creation function. To allow for nice one-liners that don&#39;t involve long create info names, <a href="#expose-create-info-args">these create info parameters are exposed</a> in the creation function, automatically building the create info structure for you.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Handle types have a constructor defined that wraps around the creation function and automatically unwrap the result (see <a href="../error_handling/#Error-handling">Error handling</a>).</p></div></div><h3 id="Automatic-finalization"><a class="docs-heading-anchor" href="#Automatic-finalization">Automatic finalization</a><a id="Automatic-finalization-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-finalization" title="Permalink"></a></h3><p>Handles can be created with the API functions <code>vkCreate*</code> and <code>vkAllocate*</code>, and most of them must be destroyed after use with a <code>vkDestroy*</code> or <code>vkFree*</code>. More importantly, they must be destroyed with the same allocator and parent handle that created them. To automate this, new mutable handle types were defined to allow for the registration of a <a href="https://docs.julialang.org/en/v1/base/base/#Base.finalizer">finalizer</a>. The <code>create_*</code> and <code>allocate_*</code> wrappers automatically register the corresponding destructor in a finalizer, so that you don&#39;t need to worry about destructors (except for <code>CommandBuffer</code>s and <code>DescriptorSet</code>s, see below). A handle&#39;s finalizer, and therefore its API destructor, will execute when there are no program-accessible references to this handle.</p><p><code>CommandBuffer</code>s and <code>DescriptorSet</code>s do not register any destructor and are never implicitly freed. You will have to explicitly free those resources yourself with <code>free_command_buffers</code> and <code>free_descriptor_sets</code> respectively. The reason for that is that they are supposed to be freed in batches for performance considerations.</p><p>Therefore, you should <strong>never</strong> explicitly call a destructor (<code>destroy_*</code> or <code>free_*</code>) except for <code>CommandBuffer</code> and <code>DescriptorSet</code>. Otherwise objects will be destroyed/freed twice, likely resulting in a crash.</p><p>Finalizers <a href="https://docs.julialang.org/en/v1/base/base/#Base.finalize">can be run with</a> <code>finalize(handle)</code>, which may be useful in situations where you want to free an object without waiting for finalizers to be triggered by the Julia runtime. This can be done safely: the finalizers won&#39;t run twice if you run them manually.</p><p>However, finalizers can be run in arbitrary order, and some handles require to be destroyed only after all their children (such as <code>VkDevice</code>s). To avoid crashes related to bad finalization execution order, a simple thread-safe reference counting system is used to make sure that a handle is destroyed <strong>only after all its children are destroyed</strong>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you need to construct a handle from an opaque pointer (obtained, for example, via an external library such as a <code>VkSurfaceKHR</code> from GLFW), you can use the constructor <code>(::Type{&lt;:Handle})(ptr::Ptr{Cvoid}, destructor[, parent])</code> as in</p><pre><code class="language-julia hljs">surface_ptr = GLFW.CreateWindowSurface(instance, window)
SurfaceKHR(surface_ptr, x -&gt; destroy_surface_khr(instance, x), instance)</code></pre><p>If you don&#39;t need to destroy the surface (for example, if the external library does it for you), then you can just pass in the <code>identity</code> function as a destructor.</p></div></div><p>This introduces a small overhead, since the parent handle and allocator are stored in an anonymous function for each handle at creation. However, it should be minor compared to the execution time of the API destructors.</p><p>Because finalization order is the source of many Vulkan bugs, particularly when objects implicitly depend on other objects being alive, there is a <a href="../getting_started/#Preferences">preference</a> <code>LOG_DESTRUCTION</code> that allows you to log all destructions if set to <code>&quot;true&quot;</code> for debugging purposes.</p><h3 id="expose-create-info-args"><a class="docs-heading-anchor" href="#expose-create-info-args">Exposition of create info arguments</a><a id="expose-create-info-args-1"></a><a class="docs-heading-anchor-permalink" href="#expose-create-info-args" title="Permalink"></a></h3><p>Handles that can only be created with a single API constructor possess an additional constructor that wraps around the generated create/allocate* functions, building the required *[Create/Allocate]Info from exposed arguments. That way, you do not have to explicitly construct this intermediate structure, which reduces boilerplate code.</p><p>For example</p><pre><code class="language-julia hljs">using Vulkan

const instance = Instance([], [])
const physical_device = first(unwrap(enumerate_physical_devices(instance)))
const device = Device(
    physical_device, [DeviceQueueCreateInfo(0, [1.])],
    [],
    [],
)

fence = unwrap(create_fence(device, FenceCreateInfo()))
fence_signaled = unwrap(
                   create_fence(
                     device,
                     FenceCreateInfo(flags=FENCE_CREATE_SIGNALED_BIT);
                   )
                 )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fence(Ptr{Nothing} @0x0000000005fbbaf8)</code></pre><p>can be replaced with</p><pre><code class="language-julia hljs">fence = unwrap(create_fence(device))
fence_signaled = unwrap(
                   create_fence(
                     device;
                     flags=FENCE_CREATE_SIGNALED_BIT,
                     )
                   )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fence(Ptr{Nothing} @0x0000000004d381c8)</code></pre><p>Note that we <code>unwrap</code> the result every time, assuming that the <code>create_fence</code> function did not return any error. See the <a href="../error_handling/#Error-handling">error handling</a> section for more information.</p><p>Furthermore, handle types have a generated constructor that exposes the same arguments as the create/allocate* functions, but automatically unwrapping the result so you don&#39;t have to call it manually. The above can then be further reduced into</p><pre><code class="language-julia hljs">fence = Fence(device)
fence_signaled = Fence(
                   device,
                   flags=FENCE_CREATE_SIGNALED_BIT;
                 )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fence(Ptr{Nothing} @0x000000000543a108)</code></pre><p>When multiple info structures are requested, only the main one has its fields exposed as function arguments:</p><pre><code class="language-julia hljs"># the ApplicationInfo has to be provided manually
Instance([], []; application_info = ApplicationInfo(v&quot;0.1&quot;, v&quot;0.1&quot;, v&quot;1.2&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Instance(Ptr{Nothing} @0x0000000006b8f250)</code></pre><p>Or, if an array of create infos is expected, then you will have to provide it yourself:</p><pre><code class="language-julia hljs"># the array of DeviceQueueCreateInfo has to be provided manually
Device(physical_device, [DeviceQueueCreateInfo(0, [1.0])], [], [])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Device(Ptr{Nothing} @0x0000000001e4bbc8)</code></pre><p>When multiple handles are constructed at the same time, no additional constructor is defined and you need to call the <code>create_*</code> function manually</p><pre><code class="language-julia hljs">command_pool = CommandPool(device, 0)
command_buffers = unwrap(
                    allocate_command_buffers(
                      device,
                      CommandBufferAllocateInfo(
                        command_pool,
                        COMMAND_BUFFER_LEVEL_PRIMARY,
                        3,
                      )
                    )
                  )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{CommandBuffer}:
 CommandBuffer(Ptr{Nothing} @0x0000000005320090)
 CommandBuffer(Ptr{Nothing} @0x00000000057fea60)
 CommandBuffer(Ptr{Nothing} @0x00000000060dfa80)</code></pre><h3 id="Parent-handle-access"><a class="docs-heading-anchor" href="#Parent-handle-access">Parent handle access</a><a id="Parent-handle-access-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-handle-access" title="Permalink"></a></h3><p>Handles store their parent handle if they have one. For example, it is possible to just carry a <code>Pipeline</code> around and access its <code>device</code> field whenever you like, and the <code>physical_device</code> field of this device and so on until you reach the instance that has no parent. That way, it is not necessary to keep all the other parent handles in scope (e.g. <code>Device</code> and <code>Instance</code> handles) to make an API call.</p><pre><code class="language-julia hljs">command_pool.device.physical_device.instance</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Instance(Ptr{Nothing} @0x0000000006b16460)</code></pre><p><code>Base.parent</code> was extended to work on handles that possess a parent handle.</p><pre><code class="language-julia hljs">parent(device) == device.physical_device == physical_device</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="Structures"><a class="docs-heading-anchor" href="#Structures">Structures</a><a id="Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Structures" title="Permalink"></a></h2><p>Vulkan structures, such as <code>Extent2D</code>, <code>InstanceCreateInfo</code> and <code>PhysicalDeviceFeatures</code> were wrapped into two different structures each.</p><p>First, there are high-level-ish structures that are easier to work with, replacing C types by idiomatic Julia types. The user will almost never need to worry about pointers, and will be able to use types such as Julia arrays, strings and version numbers in a transparent manner. All the data is stored in its fields, and is accessible just like you would expect from a Julia structure. Equality and hashing are implemented with <a href="https://github.com/andrewcooke/AutoHashEquals.jl">AutoHashEquals.jl</a>, to facilitate their use in dictionaries.</p><p>However, storing data and converting it to a C-compatible format for API calls introduce some overhead for these high-level structures. It will not matter in non performance-critical sections, but may be a limitation in tight loops. Therefore, lower-level, minimalistic types are available, which only carry the smallest possible amount of information needed to use the API. Although they can be created very similarly to high-level structures, the high-level arguments are directly converted to their C-compatible counterpart. The main drawback is a lack of introspection, since these minimalistic structures carry C types, so these structures are badly suited to keeping data around. Minimalistic structures are not defined for types that are only returned and never requested by Vulkan, such as <code>ExtensionProperties</code>.</p><p>There is a final family of Vulkan types that you may encounter. Those are the barebones VulkanCore.jl types, which you won&#39;t have to worry about in all cases <em>except when you need to pass functions to the API</em>. In this case, inputs will not be automatically converted for you, and you will have to define the appropriate signature before obtaining function pointers with <code>Base.@cfunction</code>. You can access these types from the (exported) module <code>Vulkan.core</code>.</p><p>To summarize:</p><ul><li><p>High-level structs:</p><ul><li>should be used most of the time.</li><li>store values in a way that makes it easy to retrieve them later.</li><li>introduce a small overhead, which may be a concern in some performance-critical sections.</li></ul></li><li><p>Low-level structs:</p><ul><li>offer performance advantages over high-level structs.</li><li>may be preferred in performance-critical sections.</li><li>are not meant for introspection capabilities.</li><li>are not defined for structures not needed by the API.</li></ul></li><li><p>VulkanCore structs:</p><ul><li>should never be used directly, except as argument types for functions intended to be passed to the API.</li></ul></li></ul><p>In general, high-level and low-level structs can be used interchangeably as function arguments to constructors or API functions, at the condition that they are not mixed together.</p><p>Using either high-level or low-level structs should be a performance matter, and as such it is encouraged to profile applications before using low-level structs all: they are faster, but can require additional bookkeeping due to a lack of introspection.</p><p>Typically, it is easier to use high-level types for create info arguments to handles that are created at a low frequency; this includes <code>Instance</code>, <code>Device</code> or <code>SwapchainKHR</code> handles for example. Their create info structures may contain precious information that needs to be accessed by the application, e.g. to make sure that image formats in a render pass comply with the swapchain image format, or to check instance or device extensions before using extension functionality.</p><p>API functions and structures accept either low-level structs or high-level structs. For commands with low-level structs, you currently need to provide typed arrays (i.e. not <code>[]</code> which are of type <code>Vector{Any}</code>).</p><p>In general:</p><ul><li>High-level structs are returned from functions with high-level arguments.</li><li>Low-level structs are returned from functions with low-level arguments.</li></ul><p>The only exception currently is for functions that would have the same low-level/high-level argument types, for which only one version is available that returns values in low-level types.</p><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><p>In Vulkan, version numbers are <code>UInt32</code> with a special encoding to extract major, minor and patch numbers, booleans are represented as <code>UInt32</code> values, <code>String</code>s as <code>Ptr{UInt8}</code> or <code>NTuple{N, UInt8}</code>. Those types have a natural counterpart in Julia, being respectively <code>VersionNumber</code>, <code>Bool</code> and <code>String</code> types. The wrapper makes it possible to work with these idiomatic Julia types, automatically converting them wherever necessary.</p><h3 id="Automatic-insertion-of-inferable-arguments"><a class="docs-heading-anchor" href="#Automatic-insertion-of-inferable-arguments">Automatic insertion of inferable arguments</a><a id="Automatic-insertion-of-inferable-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-insertion-of-inferable-arguments" title="Permalink"></a></h3><p>In some places, part of the arguments of a function or of the fields of a structure can only take one logical value. It can be divided into two sets:</p><ol><li>The structure type <code>sType</code> of certain structures</li><li>Arguments related to the start and length of a pointer which represents an array</li></ol><p>The second set is a consequence of using a higher-level language than C. In C, the pointer alone does not provide any information regarding the number of elements it holds. In Julia, array-like values can be constructed in many different ways, being an <code>Array</code>, a <code>NTuple</code> or other container types which provide a <code>length</code> method.</p><h4 id="Structure-type"><a class="docs-heading-anchor" href="#Structure-type">Structure type</a><a id="Structure-type-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-type" title="Permalink"></a></h4><p>Many API structures possess a <code>sType</code> field which must be set to a unique value. This is done to favor the extendability of the API, but is unnecessary boilerplate for the user. Worse, this is an error-prone process which may lead to crashes. All the constructors of this wrapper do not expose this <code>sType</code> argument, and hardcode the expected value.</p><h4 id="Pointer-lengths"><a class="docs-heading-anchor" href="#Pointer-lengths">Pointer lengths</a><a id="Pointer-lengths-1"></a><a class="docs-heading-anchor-permalink" href="#Pointer-lengths" title="Permalink"></a></h4><p>The length of array pointers is automatically deduced from the length of the container passed in as argument.</p><h4 id="Pointer-starts"><a class="docs-heading-anchor" href="#Pointer-starts">Pointer starts</a><a id="Pointer-starts-1"></a><a class="docs-heading-anchor-permalink" href="#Pointer-starts" title="Permalink"></a></h4><p>Some API functions require to specify the start of a pointer array as an argument. They have been hardcoded to 0 (first element in C), since it is always possible to pass in a sub-array (e.g. a view).</p><h2 id="Bitmask-flags"><a class="docs-heading-anchor" href="#Bitmask-flags">Bitmask flags</a><a id="Bitmask-flags-1"></a><a class="docs-heading-anchor-permalink" href="#Bitmask-flags" title="Permalink"></a></h2><p>In Vulkan, the value of some flags carry meaning through a bitmask structure. Bitmasks define bit values which they can be a composition of (using bitwise <em>and</em>, <em>or</em>, and <em>xor</em> operations). However, the associated flag type is defined as a <code>UInt32</code>, which allows any value to be passed in as a flag. This opens up the door to incorrect usage that may be hard to debug. To circumvent that, every bitmask flag now has one associated type which prevents combinations with flags of other bitmask types.</p><p>For example, consider the vanilla <code>VkSampleCountFlags</code> type (alias for <code>UInt32</code>) with bits defined via the enumerated type <code>VkSampleCountFlagBits</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Vulkan.core</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT isa VkSampleCountFlagBits</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT === VkSampleCountFlagBits(1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT === VkSampleCountFlags(1)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT === VkSampleCountFlags(3)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT &amp; VK_SAMPLE_COUNT_2_BIT === VkSampleCountFlags(0)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT &amp; VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR === VkSampleCountFlags(1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Those two types are combined into one <code>SampleCountFlag</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Vulkan</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SampleCountFlag &lt;: BitMask</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SurfaceTransformFlagKHR &lt;: BitMask # another bitmask flag</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SAMPLE_COUNT_1_BIT | SAMPLE_COUNT_2_BIT === SampleCountFlag(3)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SAMPLE_COUNT_1_BIT &amp; SAMPLE_COUNT_2_BIT === SampleCountFlag(0)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SAMPLE_COUNT_1_BIT &amp; SURFACE_TRANSFORM_IDENTITY_BIT_KHR</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: Bitwise operation not allowed between incompatible bitmasks &#39;SampleCountFlag&#39;, &#39;SurfaceTransformFlagKHR&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; UInt32(typemax(SampleCountFlag)) === UInt32(core.VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>All functions that were expecting a <code>VkSampleCountFlags</code> (<code>UInt32</code>) value will have their wrapped versions expect a value of type <code>SampleCountFlag</code>. Furthermore, the <code>*FLAG_BITS_MAX_ENUM</code> values are removed. This value is the same for all enums and can be accessed via <code>typemax(T)</code> where <code>T</code> is a <code>BitMask</code> (e.g. <code>SampleCountFlag</code>).</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting started</a><a class="docs-footer-nextpage" href="../functions/">Vulkan functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Sunday 26 September 2021 13:16">Sunday 26 September 2021</span>. Using Julia version 1.6.0-rc1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
