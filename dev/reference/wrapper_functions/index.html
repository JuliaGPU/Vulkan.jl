<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Wrapper functions · Vulkan.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Vulkan.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../intro/">Introduction</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../tutorial/error_handling/">Error handling</a></li><li><a class="tocitem" href="../../tutorial/resource_management/">Resource management</a></li><li><a class="tocitem" href="../../tutorial/indepth/">In-depth tutorial</a></li><li><a class="tocitem" href="../../tutorial/minimal_working_compute/">Running compute shaders</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../howto/preferences/">Specify package options</a></li><li><a class="tocitem" href="../../howto/debugging/">Debug an application</a></li><li><a class="tocitem" href="../../howto/handles/">Manipulate handles</a></li><li><a class="tocitem" href="../../howto/shaders/">Compile a SPIR-V shader from Julia</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../wrapper_types/">Wrapper types</a></li><li class="is-active"><a class="tocitem" href>Wrapper functions</a><ul class="internal"><li><a class="tocitem" href="#Implicit-return-values"><span>Implicit return values</span></a></li><li><a class="tocitem" href="#Queries"><span>Queries</span></a></li><li><a class="tocitem" href="#expose-create-info-args"><span>Exposing create info arguments</span></a></li><li><a class="tocitem" href="#Automatic-insertion-of-inferable-arguments"><span>Automatic insertion of inferable arguments</span></a></li><li><a class="tocitem" href="#Intermediate-functions"><span>Intermediate functions</span></a></li></ul></li><li><a class="tocitem" href="../dispatch/">API function dispatch</a></li><li><a class="tocitem" href="../options/">Package options</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../about/motivations/">Motivations</a></li><li><a class="tocitem" href="../../about/extension_mechanism/">Extension mechanism</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../utility/">Utility</a></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../dev/overview/">Overview</a></li><li><a class="tocitem" href="../../dev/spec/">Vulkan specification</a></li><li><a class="tocitem" href="../../dev/gen/">Generator</a></li><li><a class="tocitem" href="../../dev/next_chains/">Next chains</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Wrapper functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Wrapper functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGPU/Vulkan.jl/blob/master/docs/src/reference/wrapper_functions.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Wrapper-functions"><a class="docs-heading-anchor" href="#Wrapper-functions">Wrapper functions</a><a id="Wrapper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-functions" title="Permalink"></a></h1><p>Functions in C behave differently that in Julia. In particular, they can&#39;t return multiple values and mutate pointer memory instead. Other patterns emerge from the use of pointers with a separately-provided length, where a length/size parameter can be queried, so that you build a pointer with the right size, and pass it in to the API to be filled with data. All these patterns were automated, so that wrapper functions feel a lot more natural and straightforward for Julia users than the API functions.</p><h2 id="Implicit-return-values"><a class="docs-heading-anchor" href="#Implicit-return-values">Implicit return values</a><a id="Implicit-return-values-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-return-values" title="Permalink"></a></h2><p>Functions almost never directly return a value in Vulkan, and usually return either a return code or nothing. This is a limitation of C where only a single value can be returned from a function. Instead, they fill pointers with data, and it is your responsibility to initialize them before the call and dereference them afterwards. Here is an example:</p><pre><code class="language-julia hljs">using Vulkan
using .VkCore

function example_create_instance()
    instance_ref = Ref{VkInstance}()
    # We will cheat a bit for the create info.
    code = vkCreateInstance(
        InstanceCreateInfo([], []), # create info
        C_NULL,                     # allocator
        instance_ref,
    )

    @assert code == VK_SUCCESS

    instance_ref[]
end

example_create_instance()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ptr{Nothing} @0x0000000004bc11c0</code></pre><p>We did not create a <code>VkInstanceCreateInfo</code> to stay concise. Note that the create info structure can be used as is by the <code>vkCreateInstance</code>, even if it is a wrapper. Indeed, it implements <code>Base.cconvert</code> and <code>Base.unsafe_convert</code> to automatically interface with the C API.</p><p>All this setup code is now automated, with a better <a href="../../tutorial/error_handling/#Error-handling">error handling</a>.</p><pre><code class="language-julia hljs">instance = unwrap(create_instance(InstanceCreateInfo([], []); allocator = C_NULL))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Instance(Ptr{Nothing} @0x00000000049b04c0)</code></pre><p>When there are multiple implicit return values (i.e. multiple pointers being written to), they are returned as a tuple:</p><pre><code class="language-julia hljs">actual_data_size, data = unwrap(get_pipeline_cache_data(device, pipeline_cache, data_size))</code></pre><h2 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h2><h3 id="Enumerated-items"><a class="docs-heading-anchor" href="#Enumerated-items">Enumerated items</a><a id="Enumerated-items-1"></a><a class="docs-heading-anchor-permalink" href="#Enumerated-items" title="Permalink"></a></h3><p>Sometimes, when enumerating objects or properties for example, a function may need to be called twice: a first time for returning the number of elements to be enumerated, then a second time with an initialized array of the right length to be filled with Vulkan objects:</p><pre><code class="language-julia hljs">function example_enumerate_physical_devices(instance)
    pPhysicalDeviceCount = Ref{UInt32}(0)

    # Get the length in pPhysicalDeviceCount.
    code = vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, C_NULL)

    @assert code == VK_SUCCESS
    # Initialize the array with the returned length.
    pPhysicalDevices = Vector{VkPhysicalDevice}(undef, pPhysicalDeviceCount[])

    # Fill the array.
    code = vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices)
    @assert code == VK_SUCCESS

    pPhysicalDevices
end

example_enumerate_physical_devices(instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Ptr{Nothing}}:
 Ptr{Nothing} @0x000000000781e7f0</code></pre><p>The relevant enumeration functions are wrapped with this, so that only one call needs to be made, without worrying about creating intermediate arrays:</p><pre><code class="language-julia hljs">unwrap(enumerate_physical_devices(instance))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{PhysicalDevice}:
 PhysicalDevice(Ptr{Nothing} @0x000000000781e7f0)</code></pre><h3 id="Incomplete-retrieval"><a class="docs-heading-anchor" href="#Incomplete-retrieval">Incomplete retrieval</a><a id="Incomplete-retrieval-1"></a><a class="docs-heading-anchor-permalink" href="#Incomplete-retrieval" title="Permalink"></a></h3><p>Some API commands such as <code>vkEnumerateInstanceLayerProperties</code> may return a <code>VK_INCOMPLETE</code> code indicating that some items could not be written to the provided array. This happens if the number of available items changes after that the length is obtained, making the array too small. In this case, it is recommended to simply query the length again, and provide a vector of the updated size, starting over if the number of items changes again. To avoid doing this by hand, this step is automated in a while loop. Here is what it may look like:</p><pre><code class="language-julia hljs">function example_enumerate_physical_devices_2(instance)
    pPhysicalDeviceCount = Ref{UInt32}(0)

    @assert vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, C_NULL) == VK_SUCCESS
    pPhysicalDevices = Vector{VkPhysicalDevice}(undef, pPhysicalDeviceCount[])
    code = vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices)

    while code == VK_INCOMPLETE
        @assert vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, C_NULL) ==
                VK_SUCCESS
        pPhysicalDevices = Vector{VkPhysicalDevice}(undef, pPhysicalDeviceCount[])
        code = vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices)
    end

    pPhysicalDevices
end

example_enumerate_physical_devices_2(instance)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Ptr{Nothing}}:
 Ptr{Nothing} @0x000000000781e7f0</code></pre><p>The wrapper function <a href="../../api/#Vulkan.enumerate_physical_devices-Tuple{Any}"><code>enumerate_physical_devices</code></a> implements this logic, yielding</p><pre><code class="language-julia hljs">unwrap(enumerate_physical_devices(instance))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{PhysicalDevice}:
 PhysicalDevice(Ptr{Nothing} @0x000000000781e7f0)</code></pre><h2 id="expose-create-info-args"><a class="docs-heading-anchor" href="#expose-create-info-args">Exposing create info arguments</a><a id="expose-create-info-args-1"></a><a class="docs-heading-anchor-permalink" href="#expose-create-info-args" title="Permalink"></a></h2><p>Functions that take a single <code>Create*Info</code> or <code>Allocate*Info</code> structure as an argument additionally define a method where all create info parameters are unpacked. The method will then build the create info structure automatically, slightly reducing boilerplate.</p><p>For example, it is possible to create a <a href="../../api/#Vulkan.Fence-Tuple{Any}"><code>Fence</code></a> with <code>create_fence(device; flags = FENCE_CREATE_SIGNALED_BIT)</code>, instead of <code>create_fence(device, FenceCreateInfo(; flags = FENCE_CREATE_SIGNALED_BIT))</code>.</p><p>Note that this feature is also available for handle constructors in conjunction with <a href="../wrapper_types/#Handle-constructors">Handle constructors</a>, allowing <code>Fence(device; flags = FENCE_CREATE_SIGNALED_BIT)</code>.</p><h2 id="Automatic-insertion-of-inferable-arguments"><a class="docs-heading-anchor" href="#Automatic-insertion-of-inferable-arguments">Automatic insertion of inferable arguments</a><a id="Automatic-insertion-of-inferable-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-insertion-of-inferable-arguments" title="Permalink"></a></h2><p>In some places, part of the arguments of a function or of the fields of a structure can only take one logical value. It can be divided into two sets:</p><ol><li>The structure type <code>sType</code> of certain structures</li><li>Arguments related to the start and length of a pointer which represents an array</li></ol><p>The second set is a consequence of using a higher-level language than C. In C, the pointer alone does not provide any information regarding the number of elements it holds. In Julia, array-like values can be constructed in many different ways, being an <code>Array</code>, a <code>NTuple</code> or other container types which provide a <code>length</code> method.</p><h4 id="Structure-type"><a class="docs-heading-anchor" href="#Structure-type">Structure type</a><a id="Structure-type-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-type" title="Permalink"></a></h4><p>Many API structures possess a <code>sType</code> field which must be set to a unique value. This is done to favor the extendability of the API, but is unnecessary boilerplate for the user. Worse, this is an error-prone process which may lead to crashes. All the constructors of this library do not expose this <code>sType</code> argument, and hardcode the expected value.</p><p>If for any reason the structure type must be retrieved, it can be done via <code>structure_type</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; structure_type(InstanceCreateInfo)</code><code class="nohighlight hljs ansi" style="display:block;">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO::VkStructureType = 0x00000001</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; structure_type(_InstanceCreateInfo)</code><code class="nohighlight hljs ansi" style="display:block;">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO::VkStructureType = 0x00000001</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; structure_type(VkCore.VkInstanceCreateInfo)</code><code class="nohighlight hljs ansi" style="display:block;">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO::VkStructureType = 0x00000001</code></pre><h4 id="Pointer-lengths"><a class="docs-heading-anchor" href="#Pointer-lengths">Pointer lengths</a><a id="Pointer-lengths-1"></a><a class="docs-heading-anchor-permalink" href="#Pointer-lengths" title="Permalink"></a></h4><p>The length of array pointers is automatically deduced from the length of the container passed in as argument.</p><h4 id="Pointer-starts"><a class="docs-heading-anchor" href="#Pointer-starts">Pointer starts</a><a id="Pointer-starts-1"></a><a class="docs-heading-anchor-permalink" href="#Pointer-starts" title="Permalink"></a></h4><p>Some API functions require to specify the start of a pointer array as an argument. They have been hardcoded to 0 (first element), since it is always possible to pass in a sub-array (e.g. a view).</p><h2 id="Intermediate-functions"><a class="docs-heading-anchor" href="#Intermediate-functions">Intermediate functions</a><a id="Intermediate-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Intermediate-functions" title="Permalink"></a></h2><p>Similarly to <a href="../wrapper_types/#Structures">structures</a>, there are intermediate functions that accept and return <a href="../wrapper_types/#Intermediate-structures">intermediate structures</a>. For example, <a href="../../api/#Vulkan.enumerate_instance_layer_properties-Tuple{}"><code>enumerate_instance_layer_properties</code></a> which returns a <code>ResultTypes.Result{Vector{LayerProperties}}</code> has an intermediate counterpart <a href="../../api/#Vulkan._enumerate_instance_layer_properties-Tuple{}"><code>_enumerate_instance_layer_properties</code></a> which returns a <code>ResultTypes.Result{Vector{_LayerProperties}}</code>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../wrapper_types/">« Wrapper types</a><a class="docs-footer-nextpage" href="../dispatch/">API function dispatch »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 30 June 2023 14:16">Friday 30 June 2023</span>. Using Julia version 1.9.0-rc3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
