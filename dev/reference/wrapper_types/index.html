<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Wrapper types · Vulkan.jl</title><meta name="title" content="Wrapper types · Vulkan.jl"/><meta property="og:title" content="Wrapper types · Vulkan.jl"/><meta property="twitter:title" content="Wrapper types · Vulkan.jl"/><meta name="description" content="Documentation for Vulkan.jl."/><meta property="og:description" content="Documentation for Vulkan.jl."/><meta property="twitter:description" content="Documentation for Vulkan.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Vulkan.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../intro/">Introduction</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../tutorial/error_handling/">Error handling</a></li><li><a class="tocitem" href="../../tutorial/resource_management/">Resource management</a></li><li><a class="tocitem" href="../../tutorial/indepth/">In-depth tutorial</a></li><li><a class="tocitem" href="../../tutorial/minimal_working_compute/">Running compute shaders</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../howto/preferences/">Specify package options</a></li><li><a class="tocitem" href="../../howto/debugging/">Debug an application</a></li><li><a class="tocitem" href="../../howto/handles/">Manipulate handles</a></li><li><a class="tocitem" href="../../howto/shaders/">Compile a SPIR-V shader from Julia</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Wrapper types</a><ul class="internal"><li><a class="tocitem" href="#Handles"><span>Handles</span></a></li><li><a class="tocitem" href="#Structures"><span>Structures</span></a></li><li><a class="tocitem" href="#Bitmask-flags"><span>Bitmask flags</span></a></li></ul></li><li><a class="tocitem" href="../wrapper_functions/">Wrapper functions</a></li><li><a class="tocitem" href="../dispatch/">API function dispatch</a></li><li><a class="tocitem" href="../options/">Package options</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../about/motivations/">Motivations</a></li><li><a class="tocitem" href="../../about/extension_mechanism/">Extension mechanism</a></li><li><a class="tocitem" href="../../about/library_loading/">Library loading</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../utility/">Utility</a></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../dev/overview/">Overview</a></li><li><a class="tocitem" href="../../dev/spec/">Vulkan specification</a></li><li><a class="tocitem" href="../../dev/gen/">Generator</a></li><li><a class="tocitem" href="../../dev/next_chains/">Next chains</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Wrapper types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Wrapper types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGPU/Vulkan.jl/blob/main/docs/src/reference/wrapper_types.jl#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Wrapper-types"><a class="docs-heading-anchor" href="#Wrapper-types">Wrapper types</a><a id="Wrapper-types-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-types" title="Permalink"></a></h1><p>The Vulkan API possesses a few data structures that exhibit a different behavior. Each structure type has been wrapped carefully to automate the underlying API patterns. We list all of these here along with their properties and features that we hope will free the developer of some of the heaviest patterns and boilerplate of the Vulkan API.</p><h2 id="Handles"><a class="docs-heading-anchor" href="#Handles">Handles</a><a id="Handles-1"></a><a class="docs-heading-anchor-permalink" href="#Handles" title="Permalink"></a></h2><p>Handles are opaque pointers to internal Vulkan objects. Almost every handle must be created and destroyed with API commands. Some handles have a parent handle (see <a href="#Parent-handle-access">Parent handle access</a> for navigating through the resulting handle hierarchy), which <em>must not</em> be destroyed before its children. For this we provide wrappers around creation functions with an automatic finalization feature (see <a href="#Automatic-finalization">Automatic finalization</a>) that uses a simple reference couting system. This alleviates the burden of tracking when a handle can be freed and freeing it, in conformance with the Vulkan specification.</p><p>Most handles are typically created with a <code>*CreateInfo</code> or <code>*AllocateInfo</code> structure, that packs creation parameters to be provided to the API creation function. To allow for nice one-liners that don&#39;t involve long create info names, <a href="../wrapper_functions/#expose-create-info-args">these create info parameters are exposed</a> in the creation function, automatically building the create info structure.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Most handle types have constructors defined that wrap around the creation function and automatically unwrap the result (see <a href="../../tutorial/error_handling/#Error-handling">Error handling</a>).</p></div></div><h3 id="Automatic-finalization"><a class="docs-heading-anchor" href="#Automatic-finalization">Automatic finalization</a><a id="Automatic-finalization-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-finalization" title="Permalink"></a></h3><p>In the Vulkan API, handles are created with the functions <code>vkCreate*</code> and <code>vkAllocate*</code>, and most of them must be destroyed after use with a call to <code>vkDestroy*</code> or <code>vkFree*</code>. More importantly, they must be destroyed with the same allocator and parent handle that created them.</p><p>To automate this, new mutable handle types were defined to allow for the registration of a <a href="https://docs.julialang.org/en/v1/base/base/#Base.finalizer">finalizer</a>. The <code>create_*</code> and <code>allocate_*</code> wrappers automatically register the corresponding destructor in a finalizer, so that you don&#39;t need to worry about destructors (except for <code>CommandBuffer</code>s and <code>DescriptorSet</code>s, see below). The finalizer of a handle, and therefore its API destructor, will execute when there are no program-accessible references to this handle. Because finalizers may run in arbitrary order in Julia, and some handle types such as <code>VkDevice</code> require to be destroyed only after all their children, a simple thread-safe reference counting system is used to make sure that a handle is destroyed <strong>only after all its children are destroyed</strong>.</p><p>As an exception, because they are meant to be freed in batches, <code>CommandBuffer</code>s and <code>DescriptorSet</code>s do not register any destructor and are not automatically freed. Those handles will have to explicitly freed with <a href="../../api/#Vulkan.free_command_buffers-Tuple{Any, Any, AbstractArray}"><code>free_command_buffers</code></a> and <a href="../../api/#Vulkan.free_descriptor_sets-Tuple{Any, Any, AbstractArray}"><code>free_descriptor_sets</code></a> respectively.</p><p>Finalizers can be run eagerly with <a href="https://docs.julialang.org/en/v1/base/base/#Base.finalize"><code>finalize</code></a>, which allows one to reclaim resources early. The finalizers won&#39;t run twice if triggered manually.</p><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>You should <strong>never</strong> explicitly call a destructor, except for <code>CommandBuffer</code> and <code>DescriptorSet</code>. Otherwise, the object will be destroyed twice and will lead to a segmentation fault.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you need to construct a handle from an opaque pointer (obtained, for example, via an external library such as a <code>VkSurfaceKHR</code> from GLFW), you can use the constructor <code>(::Type{&lt;:Handle})(ptr::Ptr{Cvoid}, destructor[, parent])</code> as in</p><pre><code class="language-julia hljs">surface_ptr = GLFW.CreateWindowSurface(instance, window)
SurfaceKHR(surface_ptr, x -&gt; destroy_surface_khr(instance, x), instance)</code></pre><p>If the surface doesn&#39;t need to be destroyed (for example, if the external library does it automatically), the <code>identity</code> function should be passed in as destructor.</p></div></div><h3 id="Handle-constructors"><a class="docs-heading-anchor" href="#Handle-constructors">Handle constructors</a><a id="Handle-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Handle-constructors" title="Permalink"></a></h3><p>Handles that can only be created with a single API constructor have constructors defined which wrap the relevant create/allocate* function and <code>unwrap</code> the result.</p><p>For example, <code>Instance(layers, extensions)</code> is equivalent to <code>unwrap(create_instance(layers, extensions))</code>.</p><p>If the API constructor returns an error, an exception will be raised (see <a href="../../tutorial/error_handling/#Error-handling">Error handling</a>).</p><h3 id="Parent-handle-access"><a class="docs-heading-anchor" href="#Parent-handle-access">Parent handle access</a><a id="Parent-handle-access-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-handle-access" title="Permalink"></a></h3><p>Handles store their parent handle if they have one. For example, <code>Pipeline</code>s have a <code>device</code> field as a <a href="../../api/#Vulkan.Device-Tuple{Any, AbstractArray, AbstractArray, AbstractArray}"><code>Device</code></a>, which itself contains a <code>physical_device</code> field and so on until the instance that has no parent. This reduces the number of objects that must be carried around in user programs.</p><p><code>Base.parent</code> was extended to navigate this hierarchy, where for example <code>parent(device) == device.physical_device</code> and <code>parent(physical_device) == physical_device.instance</code>.</p><h2 id="Structures"><a class="docs-heading-anchor" href="#Structures">Structures</a><a id="Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Structures" title="Permalink"></a></h2><p>Vulkan structures, such as <code>Extent2D</code>, <code>InstanceCreateInfo</code> and <code>PhysicalDeviceFeatures</code> were wrapped into two different structures each: a high-level structure, which should be used most of the time, and an intermediate structure used for maximal performance whenever required.</p><h3 id="High-level-structures"><a class="docs-heading-anchor" href="#High-level-structures">High-level structures</a><a id="High-level-structures-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-structures" title="Permalink"></a></h3><p>High-level structures were defined to ressemble idiomatic Julia structures, replacing C types by idiomatic Julia types. They abstract most pointers away, using Julia arrays and strings, and use <code>VersionNumbers</code> instead of integers. Equality and hashing are implemented with <a href="https://github.com/jolin-io/StructEquality.jl">StructEquality.jl</a> to facilitate their use in dictionaries.</p><h3 id="Intermediate-structures"><a class="docs-heading-anchor" href="#Intermediate-structures">Intermediate structures</a><a id="Intermediate-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Intermediate-structures" title="Permalink"></a></h3><p>Intermediate structures wrap C-compatible structures and embed pointer data as dependencies. Therefore, as long as the intermediate structure lives, all pointer data contained within the C-compatible structure will be valid. These structures are mostly used internally by Vulkan.jl, but they can be used with <a href="../wrapper_functions/#Intermediate-functions">intermediate functions</a> for maximum performance, avoiding the overhead incurred by high-level structures which require back and forth conversions with C-compatible structures for API calls.</p><p>These intermediate structures share the name of the high-level structures, starting with an underscore. For example, the high-level structure <a href="../../api/#Vulkan.InstanceCreateInfo"><code>InstanceCreateInfo</code></a> has an intermediate counterpart <a href="../../api/#Vulkan._InstanceCreateInfo"><code>_InstanceCreateInfo</code></a>.</p><p>Note that intermediate structures can only be used with other intermediate structures. <code>convert</code> methods allow the conversion between arbitrary high-level and intermediate structures, if required.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Outside performance-critical sections such as tight loops, high-level structures are much more convenient to manipulate and should be used instead.</p></div></div><h2 id="Bitmask-flags"><a class="docs-heading-anchor" href="#Bitmask-flags">Bitmask flags</a><a id="Bitmask-flags-1"></a><a class="docs-heading-anchor-permalink" href="#Bitmask-flags" title="Permalink"></a></h2><p>In the Vulkan API, certain flags use a bitmask structure. A bitmask is a logical <code>or</code> combination of several bit values, whose meaning is defined by the bitmask type. In Vulkan, the associated flag type is defined as a <code>UInt32</code>, which allows any value to be passed in as a flag. This opens up the door to incorrect usage that may be hard to debug. To circumvent that, most bitmask flags were wrapped with an associated type which prevents combinations with flags of other bitmask types.</p><p>For example, consider the core <code>VkSampleCountFlags</code> type (alias for <code>UInt32</code>) with bits defined via the enumerated type <code>VkSampleCountFlagBits</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Vulkan.VkCore</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT isa VkSampleCountFlagBits</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT === VkSampleCountFlagBits(1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT === VkSampleCountFlags(1)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT === VkSampleCountFlags(3)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT &amp; VK_SAMPLE_COUNT_2_BIT === VkSampleCountFlags(0)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; VK_SAMPLE_COUNT_1_BIT &amp; VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR === VkSampleCountFlags(1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Those two types are combined into one <code>SampleCountFlag</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Vulkan</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SampleCountFlag &lt;: BitMask</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SurfaceTransformFlagKHR &lt;: BitMask # another bitmask flag</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SAMPLE_COUNT_1_BIT | SAMPLE_COUNT_2_BIT === SampleCountFlag(3)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SAMPLE_COUNT_1_BIT &amp; SAMPLE_COUNT_2_BIT === SampleCountFlag(0)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SAMPLE_COUNT_1_BIT &amp; SURFACE_TRANSFORM_IDENTITY_BIT_KHR</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: Bitwise operation not allowed between incompatible BitMasks &#39;SampleCountFlag&#39;, &#39;SurfaceTransformFlagKHR&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; UInt32(typemax(SampleCountFlag)) === UInt32(VkCore.VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>All functions that were expecting a <code>VkSampleCountFlags</code> (<code>UInt32</code>) value will have their wrapped versions expect a value of type <code>SampleCountFlag</code>. Furthermore, the <code>*FLAG_BITS_MAX_ENUM</code> values are removed. This value is the same for all enums and can be accessed via <code>typemax(T)</code> where <code>T</code> is a <code>BitMask</code> (e.g. <code>SampleCountFlag</code>).</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../howto/shaders/">« Compile a SPIR-V shader from Julia</a><a class="docs-footer-nextpage" href="../wrapper_functions/">Wrapper functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Saturday 6 July 2024 12:50">Saturday 6 July 2024</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
