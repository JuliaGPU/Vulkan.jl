<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Motivations · Vulkan.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Vulkan.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../intro/">Introduction</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../tutorial/error_handling/">Error handling</a></li><li><a class="tocitem" href="../../tutorial/resource_management/">Resource management</a></li><li><a class="tocitem" href="../../tutorial/indepth/">In-depth tutorial</a></li><li><a class="tocitem" href="../../tutorial/minimal_working_compute/">Running compute shaders</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../howto/preferences/">Specify package options</a></li><li><a class="tocitem" href="../../howto/debugging/">Debug an application</a></li><li><a class="tocitem" href="../../howto/handles/">Manipulate handles</a></li><li><a class="tocitem" href="../../howto/shaders/">Compile a SPIR-V shader from Julia</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/wrapper_types/">Wrapper types</a></li><li><a class="tocitem" href="../../reference/wrapper_functions/">Wrapper functions</a></li><li><a class="tocitem" href="../../reference/dispatch/">API function dispatch</a></li><li><a class="tocitem" href="../../reference/options/">Package options</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li class="is-active"><a class="tocitem" href>Motivations</a><ul class="internal"><li><a class="tocitem" href="#Automating-low-level-patterns"><span>Automating low-level patterns</span></a></li><li><a class="tocitem" href="#Structures-and-variable-preservation"><span>Structures and variable preservation</span></a></li></ul></li><li><a class="tocitem" href="../extension_mechanism/">Extension mechanism</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../utility/">Utility</a></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../../dev/overview/">Overview</a></li><li><a class="tocitem" href="../../dev/spec/">Vulkan specification</a></li><li><a class="tocitem" href="../../dev/gen/">Generator</a></li><li><a class="tocitem" href="../../dev/next_chains/">Next chains</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Explanations</a></li><li class="is-active"><a href>Motivations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Motivations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGPU/Vulkan.jl/blob/master/docs/src/about/motivations.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Motivations"><a class="docs-heading-anchor" href="#Motivations">Motivations</a><a id="Motivations-1"></a><a class="docs-heading-anchor-permalink" href="#Motivations" title="Permalink"></a></h1><h2 id="Automating-low-level-patterns"><a class="docs-heading-anchor" href="#Automating-low-level-patterns">Automating low-level patterns</a><a id="Automating-low-level-patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Automating-low-level-patterns" title="Permalink"></a></h2><p>Vulkan is a low-level API that exhibits many patterns than any C library exposes. For example, some functions return error codes as a result, or mutate pointer memory as a way of returning values. Arrays are requested in the form of a pointer and a length. Pointers are used in many places; and because their dependency to their pointed data escapes the Julia compiler and the garbage collection mechanism, it is not trivial to keep pointers valid, i.e.: to have them point to valid <em>unreclaimed</em> memory. These pitfalls lead to crashes. Furthermore, the Vulkan C API makes heavy use of structures with pointer fields and structure pointers, requiring from the Julia runtime a clear knowledge of variable preservation.</p><p>Usually, the patterns mentioned above are not problematic for small libraries, because the C structures involved are relatively simple. Vulkan being a large API, however, patterns start to feel heavy: they require lots of boilerplate code and any mistake is likely to result in a crash. That is why we developped a procedural approach to automate these patterns.</p><p>Vulkan.jl uses a generator to programmatically generate higher-level wrappers for low-level API functions. This is a critical part of this library, which helped us to minimize the amount of human errors in the wrapping process, while allowing a certain flexilibity. The related project is contained in the <code>generator</code> folder. Because its unique purpose is to generate wrappers, it is not included in the package, reducing the number of dependencies.</p><h2 id="Structures-and-variable-preservation"><a class="docs-heading-anchor" href="#Structures-and-variable-preservation">Structures and variable preservation</a><a id="Structures-and-variable-preservation-1"></a><a class="docs-heading-anchor-permalink" href="#Structures-and-variable-preservation" title="Permalink"></a></h2><p>Since the original Vulkan API is written in C, there are a lot of pointers to deal with and handling them is not always an easy task. With a little practice, one can figure out how to wrap function calls with <code>cconvert</code> and <code>unsafe_convert</code> provided by Julia. Those functions provide automatic conversions and <code>ccall</code> GC-roots <code>cconvert</code>ed variables to ensure that pointers will point to valid memory, by explicitly telling the compiler not to garbage-collect nor optimize away the original variable.</p><p>However, the situation gets a lot more complicated when you deal with pointers as type fields. We will look at a naive example that show how difficult it can get for a Julia developer unfamiliar with calling C code. If we wanted to create a <code>VkInstance</code>, we might be tempted to do:</p><pre><code class="language-julia hljs">using Vulkan.VkCore

function create_instance(app_name, engine_name)
    app_info = VkApplicationInfo(
        VK_STRUCTURE_TYPE_APPLICATION_INFO, # sType
        C_NULL, # pNext
        pointer(app_name), # application name
        1, # application version
        pointer(engine_name), # engine name
        0, # engine version
        VK_VERSION_1_2, # requested API version
    )
    create_info = InstanceCreateInfo(
        VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, # sType
        C_NULL, # pNext
        0, # flags
        Base.unsafe_convert(Ptr{VkApplicationInfo}, (Ref(app_info))), # application info
        0, # layer count
        C_NULL, # layers (none requested)
        0, # extension count
        C_NULL, # extensions (none requested)
    )
    p_instance = Ref{VkInstance}()

    GC.@preserve app_info begin
        vkCreateInstance(
            Ref(create_info),
            C_NULL, # custom allocator (we choose the default one provided by Vulkan)
            p_instance,
        )
    end

    p_instance[]
end

# instance = create_instance(&quot;AppName&quot;, &quot;NoEngine&quot;) # very likely to segfault</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">create_instance (generic function with 1 method)</code></pre><p>which will probably result in a segmentation fault. Why?</p><p>Two causes may lead to such a result:</p><ol><li><code>app_name</code> and <code>engine_name</code> may never be allocated if the compiler decides not to, so there is no guarantee that <code>pointer(app_name)</code> and <code>pointer(engine_name)</code> will point to anything valid. Additionally, even if those variables were allocated with valid pointer addresses at some point, they can be garbage collected <strong>at any time</strong>, including before the call to <code>vkCreateInstance</code>.</li><li><code>app_info</code> is not what should be preserved. It cannot be converted to a pointer, but a <code>Ref</code> to it can. Therefore it is the reference that needs to be <code>GC.@preserve</code>d, not <code>app_info</code>. So, <code>Ref(app_info)</code> must be assigned to a variable, and replace <code>app_info</code> in the call to <code>GC.@preserve</code>.</li></ol><p>Basically, it all comes down to having to preserve everything you take a pointer of. And, if you need to create an intermediary object when converting a variable to a pointer, you need to preserve it too. For example, take of an array of <code>String</code>s, that need to be converted as a <code>Ptr{Cstring}</code>. You first need to create an array of <code>Cstring</code>s, then convert that array to a pointer. The <code>String</code>s and the <code>Cstring</code> array need to be preserved.</p><p>This is exactly what <code>cconvert</code> and <code>unsafe_convert</code> are for. <code>cconvert</code> converts a variable to a type that can be converted to the desired (possibly pointer) type using <code>unsafe_convert</code>. In addition of chaining both conversions, <code>ccall</code> also preserves the <code>cconvert</code>ed variable, so that the unsafe conversion becomes safe.</p><p>Because we cannot use <code>ccall</code> in this case, we need to <code>cconvert</code> any argument that will be transformed to a pointer, and store the result as long as the desired struct may be used. Then, <code>unsafe_convert</code> can be called on this result, to get the desired (pointer) type necessary to construct the API struct.</p><p>There are several possibilities for preserving what we may call &quot;pointer dependencies&quot;. One of them is to reference them inside a global variable, such as a <code>Dict</code>, and deleting them once we no longer need it. This has the severe disadvantage of requiring to explicitly manage every dependency, along with large performance issues. Another possibility, which we have taken in this wrapper, is to create a new structure that will store both the API structure and the required dependencies. That way, we can safely rely on the GC for preserving what we need just when we need it.</p><p>Therefore, every API structure is wrapped inside another one (without the &quot;Vk&quot; prefix), as follows:</p><pre><code class="language-julia hljs">abstract type VulkanStruct{has_deps} end

struct InstanceCreateInfo &lt;: VulkanStruct{true}
    vks::VkInstanceCreateInfo # API struct
    deps::Vector{Any}         # contains all required dependencies
end</code></pre><p>and every structure exposes a convenient constructor that works perfectly with <code>String</code>s and mutable <code>AbstractArray</code>s. No manual <code>Ref</code>s/<code>cconvert</code>/<code>unsafe_convert</code> needed.</p><p>We hope that the additional <code>Vector{Any}</code> will not introduce too much overhead. In the future, this might be changed to a <code>NTuple{N, Any}</code> or a <code>StaticArrays.SVector{N, Any}</code>. We could also have stored dependencies as additional fields, but this does not scale well with nested structs. It would either require putting an additional field for each dependency (be it direct, or indirect dependencies coming from a pointer to another struct), possibly defining other structures that hold dependencies to avoid having a large number of fields, inducing additional compilation time.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p><code>cconvert</code>/<code>unsafe_convert</code> were extended on wrapper types so that, when using an API function directly, <a href="https://docs.julialang.org/en/v1/base/c/#ccall"><code>ccall</code></a> will convert a struct to its API-compatible version.</p></div></div><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../reference/options/">« Package options</a><a class="docs-footer-nextpage" href="../extension_mechanism/">Extension mechanism »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 10 February 2023 11:53">Friday 10 February 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
