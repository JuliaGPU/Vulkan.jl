<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Features · Vulkan.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Vulkan.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../design/">Design</a></li><li class="is-active"><a class="tocitem" href>Features</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#error-handling"><span>Error handling</span></a></li><li><a class="tocitem" href="#Handles"><span>Handles</span></a></li><li><a class="tocitem" href="#Bitmask-flags"><span>Bitmask flags</span></a></li><li class="toplevel"><a class="tocitem" href="#preferences"><span>Preferences</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../utility/">Utility</a></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../dev/">Developer documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Features</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Features</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGPU/Vulkan.jl/blob/master/docs/src/features.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h1><p>This wrapper exposes several features aimed at simplifying the use of the Vulkan API from Julia. Some features are configurable through the recent <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a> package, see <a href="#preferences">the corresponding section</a> for a list of available options.</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><h3 id="Implicit-return-values"><a class="docs-heading-anchor" href="#Implicit-return-values">Implicit return values</a><a id="Implicit-return-values-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-return-values" title="Permalink"></a></h3><p>Functions almost never directly return a value in Vulkan, and usually return either a return code or nothing. This is a limitation of C where only one value can be returned. Instead, they fill pointers with data, and it is your responsibility to initialize them before the call and dereference them afterwards. In Julia, it can be repetitive, requiring a special handling such as</p><pre><code class="language-julia">pDisplay = Ref{VkDisplayKHR}()
code = vkGetRandROutputDisplayEXT(physical_device, dpy_ref, rr_output, pDisplay) # just leave the return code
pDisplay[]

# or, showing what is actually done by the wrapper instead
DisplayKHR(pDisplay[], identity, physical_device)</code></pre><p>This particular setup is taken care of by the wrapper, so that you only need to do:</p><pre><code class="language-julia"># returns a Result{DisplayKHR,VulkanError}
display = get_rand_r_output_display_ext(physical_device, dpy_ref, rr_output)</code></pre><p>The <code>display</code> variable here is a <code>Result</code> type, so you would need to <code>unwrap</code> it to get the actual <code>DisplayKHR</code> type. To know more about <code>unwrap</code> and the <code>Result</code> type see the <a href="#error-handling">error handling</a> section. When there are multiple implicit return values (i.e. multiple pointers being written to), they are returned as a tuple:</p><pre><code class="language-julia"># returns a Result{Tuple{UInt, Ptr{Cvoid}},VulkanError}
actual_data_size, data = get_pipeline_cache_data(device, pipeline_cache, data_size)</code></pre><h3 id="Enumerated-arrays"><a class="docs-heading-anchor" href="#Enumerated-arrays">Enumerated arrays</a><a id="Enumerated-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Enumerated-arrays" title="Permalink"></a></h3><p>Sometimes, when enumerating objects or properties for example, a function may need to be called twice: a first time for returning the number of elements to be enumerated, then a second time with an initialized array of the right length to be filled with Vulkan objects:</p><pre><code class="language-julia">pPhysicalDeviceCount = Ref{UInt32}(0)

# get the length in pPhysicalDeviceCount
@check vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, C_NULL)

# initialize the array with the returned length
pPhysicalDevices = Vector{VkPhysicalDevice}(undef, pPhysicalDeviceCount[])

@check vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices)

# optional
PhysicalDevices.(pPhysicalDevices, identity, instance)</code></pre><p>The relevant enumeration functions are wrapped with this, so that only one call needs to be made, without worrying about creating intermediate arrays:</p><pre><code class="language-julia"># returns a Result{Vector{PhysicalDevice},VulkanError}
physical_devices = enumerate_physical_devices(instance)</code></pre><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h3 id="Structures"><a class="docs-heading-anchor" href="#Structures">Structures</a><a id="Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Structures" title="Permalink"></a></h3><p>As the API is written in C, there are a lot of pointers to deal with and handling them is not always an easy task. With a little practice, one can figure out how to wrap function calls with <code>cconvert</code> and <code>unsafe_convert</code> provided by Julia. Those functions provide automatic conversions and <code>ccall</code> GC-roots <code>cconvert</code>ed variables to ensure that pointers will point to valid memory (by explicitly telling the compiler not to garbage-collect nor optimize away the original variable).</p><p>However, the situation gets a lot more complicated when you deal with pointers as type fields. We will look at a naive example that show how difficult it can get for a Julia developer not used to calling C code. If we wanted to create a <code>VkInstance</code>, we might be tempted to do:</p><pre><code class="language-julia">function create_instance(app_name, engine_name)
    app_info = VkApplicationInfo(
        VK_STRUCTURE_TYPE_APPLICATION_INFO, # sType
        C_NULL, # pNext
        pointer(app_name), # application name
        1, # application version
        pointer(engine_name), # engine name
        0, # engine version
        VK_VERSION_1_2, # requested API version
    )
    create_info = InstanceCreateInfo(
        VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, # sType
        C_NULL, # pNext
        0, # flags
        Base.unsafe_convert(Ptr{VkApplicationInfo}, (Ref(app_info))), # application info
        0, # layer count
        C_NULL, # layers (none requested)
        0, # extension count
        C_NULL, # extensions (none requested)
    )
    p_instance = Ref{VkInstance}()

    GC.@preserve app_info begin
        vkCreateInstance(
            Ref(create_info),
            C_NULL, # custom allocator (we choose the default one provided by Vulkan)
            p_instance,
        )
    end

    p_instance[]
end

instance = create_instance(&quot;AppName&quot;, &quot;NoEngine&quot;) # very likely to segfault</code></pre><p>which will probably result in a segmentation fault. Why?</p><p>Two causes may lead to such a result:</p><ol><li><code>app_name</code> and <code>engine_name</code> may never be allocated if the compiler decides not to, so there is no guarantee that <code>pointer(app_name)</code> and <code>pointer(engine_name)</code> will point to anything valid. Additionally, even if those variables were allocated with valid pointer addresses at some point, they can be garbage collected <strong>at any time</strong>, including before the call to <code>vkCreateInstance</code>.</li><li><code>app_info</code> is not what should be preserved. It cannot be converted to a pointer, but a <code>Ref</code> to it can. Therefore it is the reference that needs to be <code>GC.@preserve</code>d, not <code>app_info</code>. So, <code>Ref(app_info)</code> must be assigned to a variable, and replace <code>app_info</code> in the call to <code>GC.@preserve</code>.</li></ol><p>Basically, it all comes down to having to preserve everything you take a pointer of. And, if you need to create an intermediary object when converting a variable to a pointer, you need to preserve it too. For example, take of an array of <code>String</code>s, that need to be converted as a <code>Ptr{Cstring}</code>. You first need to create an array of <code>Cstring</code>s, then convert that array to a pointer. The <code>String</code>s and the <code>Cstring</code> array need to be preseved.</p><p>This is exactly what <code>cconvert</code> and <code>unsafe_convert</code> are for. <code>cconvert</code> converts a variable to a type that can be converted to the desired (possibly pointer) type using <code>unsafe_convert</code>. In addition of chaining both conversions, <code>ccall</code> also preserves the <code>cconvert</code>ed variable, so that the unsafe conversion becomes safe.</p><p>Because we cannot use <code>ccall</code> in this case, we need to <code>cconvert</code> any argument that will be transformed to a pointer, and store the result as long as the desired struct may be used. Then, <code>unsafe_convert</code> can be called on this result, to get the desired (pointer) type necessary to construct the API struct.</p><p>There are several possibilities for preserving what we may call &quot;pointer dependencies&quot;. One of them is to reference them inside a global variable, such as a <code>Dict</code>, and deleting them once we no longer need it. This has the severe disadvantage of requiring to explicitly manage every dependency, along with large performance issues. Another possibility, which we have taken in this wrapper, is to create a new structure that will store both the API structure and the required dependencies. That way, we can safely rely on the GC for preserving what we need just when we need it.</p><p>Therefore, every API structure is wrapped inside another one (without the &quot;Vk&quot; prefix), as follows:</p><pre><code class="language-julia">struct InstanceCreateInfo &lt;: VulkanStruct{true} # true means there are dependencies
    vks::VkInstanceCreateInfo # API struct
    deps::Vector{Any}         # contains all required dependencies
end</code></pre><p>and every structure exposes a convenient constructor that works perfectly with <code>String</code>s and mutable <code>AbstractArray</code>s. No manual <code>Ref</code>s/<code>cconvert</code>/<code>unsafe_convert</code> needed.</p><p>We hope that the additional <code>Vector{Any}</code> will not introduce too much overhead. In the future, this might be changed to a <code>NTuple{N, Any}</code> or a <code>StaticArrays.SVector{N, Any}</code>. We could also have stored dependencies as additional fields, but this does not scale well with nested structs. It would either require putting an additional field for each dependency (be it direct, or indirect dependencies coming from a pointer to another struct), possibly defining other structures that hold dependencies to avoid having a large number of fields, inducing additional compilation time.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>cconvert</code>/<code>unsafe_convert</code> were extended so that, when using an API function directly, <a href="https://docs.julialang.org/en/v1/base/c/#ccall"><code>ccall</code></a> will convert a struct to its <code>vks</code> field. Therefore, there is no need to specify it manually in that case.</p></div></div><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><p>In Vulkan, version numbers are <code>UInt32</code> with a special encoding to extract major, minor and patch numbers, booleans are represented as <code>UInt32</code> values, <code>String</code>s as <code>Ptr{UInt8}</code> or <code>NTuple{N, UInt8}</code>. Those types have a natural counterpart in Julia, being respectively <code>VersionNumber</code>, <code>Bool</code> and <code>String</code> types. The wrapper makes it possible to work with these Julian types, automatically converting them wherever necessary.</p><h3 id="Automatic-insertion-of-inferable-arguments"><a class="docs-heading-anchor" href="#Automatic-insertion-of-inferable-arguments">Automatic insertion of inferable arguments</a><a id="Automatic-insertion-of-inferable-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-insertion-of-inferable-arguments" title="Permalink"></a></h3><p>In some places, part of the arguments of a function or of the fields of a structure can only take one logical value. It can be divided into two sets:</p><ol><li>The structure type <code>sType</code> of certain structures</li><li>Arguments related to the start and length of a pointer which represents an array</li></ol><p>The second set is a consequence of using a higher-level language than C. In C, the pointer alone does not provide any information regarding the number of elements it holds. In Julia, array-like values can be constructed in many different ways, being an <code>Array</code>, a <code>NTuple</code> or other container types which provide a <code>length</code> method.</p><h4 id="Structure-type"><a class="docs-heading-anchor" href="#Structure-type">Structure type</a><a id="Structure-type-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-type" title="Permalink"></a></h4><p>Many API structures possess a <code>sType</code> field which must be set to a unique value. This is done to favor the extendability of the API, but is unnecessary boilerplate for the user. Worse, this is an error-prone process which may lead to crashes. All the constructors of this wrapper do not expose this <code>sType</code> argument, and hardcode the expected value.</p><h4 id="Pointer-lengths"><a class="docs-heading-anchor" href="#Pointer-lengths">Pointer lengths</a><a id="Pointer-lengths-1"></a><a class="docs-heading-anchor-permalink" href="#Pointer-lengths" title="Permalink"></a></h4><p>The length of array pointers is automatically deduced from the length of the container passed in as argument.</p><h4 id="Pointer-starts"><a class="docs-heading-anchor" href="#Pointer-starts">Pointer starts</a><a id="Pointer-starts-1"></a><a class="docs-heading-anchor-permalink" href="#Pointer-starts" title="Permalink"></a></h4><p>Some API functions require to specify the start of a pointer array as an argument. They have been hardcoded to 0 (first element), since it is always possible (and very straightforward) to pass in a sub-array.</p><h2 id="error-handling"><a class="docs-heading-anchor" href="#error-handling">Error handling</a><a id="error-handling-1"></a><a class="docs-heading-anchor-permalink" href="#error-handling" title="Permalink"></a></h2><p>Error handling is achieved via <a href="https://github.com/iamed2/ResultTypes.jl">ResultTypes.jl</a> to avoid the large overhead incurred by <code>try</code>/<code>catch</code> blocks. All functions that need to perform an operation that returns a <code>VkResult</code> are wrapped into a <code>Result</code>, which contains a <a href="../api/#Vulkan.VulkanError"><code>VulkanError</code></a> if a non-success code is encountered. Custom error handling can be performed using the following pattern</p><pre><code class="language-julia">res = create_instance(InstanceCreateInfo([], []))
if iserror(res) # handle the error
    err = unwrap_error(res)
    if err.code == VK_ERROR_INCOMPATIBLE_DRIVER
        error(&quot;No driver compatible with the requested API version could be found.
                Please make sure that a driver supporting Vulkan is installed, and
                that it is up to date with the requested version.&quot;)
    else
        throw(err)
    end
else # get the instance
    unwrap(res)
end</code></pre><pre class="documenter-example-output">Instance(Ptr{Nothing} @0x0000000003989000)</pre><p>Note that calling <code>unwrap</code> directly on the result will throw any contained <code>VulkanError</code> if there is one. So, if you just want to throw an exception when encountering an error, you can do</p><pre><code class="language-julia">unwrap(create_instance(InstanceCreateInfo([], [])))</code></pre><pre class="documenter-example-output">Instance(Ptr{Nothing} @0x000000000453d700)</pre><p>Because it may be tedious to unwrap everything by hand and explicitly set the create info structures, <a href="#expose-create-info-args">convenience constructors</a> are defined for handle types so that you can just do</p><pre><code class="language-julia">Instance([], [])</code></pre><pre class="documenter-example-output">Instance(Ptr{Nothing} @0x0000000004695cc0)</pre><p>However, note that exceptions are thrown whenever the result is an error with this shorter approach.</p><p>For more details on the <code>Result</code> type and how to handle it, please consult the <a href="https://iamed2.github.io/ResultTypes.jl/stable/">ResultTypes documentation</a>.</p><h2 id="Handles"><a class="docs-heading-anchor" href="#Handles">Handles</a><a id="Handles-1"></a><a class="docs-heading-anchor-permalink" href="#Handles" title="Permalink"></a></h2><h3 id="Automatic-finalization"><a class="docs-heading-anchor" href="#Automatic-finalization">Automatic finalization</a><a id="Automatic-finalization-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-finalization" title="Permalink"></a></h3><p>Handles can be created with the API functions <code>vkCreate*</code> and <code>vkAllocate*</code>, and most of them must be destroyed after use with a <code>vkDestroy*</code> or <code>vkFree*</code>. More importantly, they must be destroyed with the same allocator and parent handle that created them. To facilitate this, new mutable handle types were defined to allow for the registration of a finalizer. Instead of having to manually specify the finalizer for each handle instance, the <code>create_*</code> and <code>allocate_*</code> wrappers automatically register the corresponding destructor.</p><p>However, finalizers can be run in arbitrary order, and some handles require to be destroyed only after all their children (such as <code>VkDevice</code>s). To avoid crashes related to bad finalization execution order, a simple thread-safe reference counting system is used to make sure that a handle is destroyed <strong>only after all its children are destroyed</strong>.</p><p>This introduces a small overhead, since the parent handle and allocator are stored in an anonymous function for each handle at creation. However, it should be minor compared to the execution time of the API destructors.</p><p>There are exceptions to the described above. <code>CommandBuffer</code>s and <code>DescriptorSet</code>s do not register any destructor and are never implicitly freed. You will have to explicitly free those resources yourself with <code>free_command_buffers</code> and <code>free_descriptor_sets</code> respectively. The reason for that is that they are supposed to be freed in batches for performance considerations. Please note also that, except for these two handle types, you should <strong>never</strong> explicitly call the destructors, otherwise they will be destroyed twice, likely resulting in a crash.</p><p>Because finalization order is the source of many Vulkan bugs, particularly when objects implicitly depend on other objects being alive, there is a <a href="#preferences">preference</a> <code>LOG_DESTRUCTION</code> that allows you to log all destructions if set to <code>&quot;true&quot;</code>.</p><h3 id="expose-create-info-args"><a class="docs-heading-anchor" href="#expose-create-info-args">Expose *[Create/Allocate]Info arguments</a><a id="expose-create-info-args-1"></a><a class="docs-heading-anchor-permalink" href="#expose-create-info-args" title="Permalink"></a></h3><p>Handles that can only be created with a single API constructor possess an additional constructor that wraps around the generated create/allocate* functions, building the required *[Create/Allocate]Info from exposed arguments. That way, you do not have to explicitly construct this intermediate structure, which reduces boilerplate code.</p><p>For example</p><pre><code class="language-julia">fence = unwrap(create_fence(device, FenceCreateInfo()))
fence_signaled = unwrap(create_fence(device, FenceCreateInfo(flags=VK_FENCE_CREATE_SIGNALED_BIT);
                       allocator=my_allocator))</code></pre><p>can be replaced with</p><pre><code class="language-julia">fence = unwrap(create_fence(device))
fence_signaled = unwrap(create_fence(device; flags=VK_FENCE_CREATE_SIGNALED_BIT, allocator=my_allocator))</code></pre><p>Note that we <code>unwrap</code> the result every time, assuming that the <code>create_fence</code> function did not return any error. See the <a href="#error-handling">error handling</a> section for more information.</p><p>Furthermore, handle types have a generated constructor that exposes the same arguments as the create/allocate* functions, but automatically unwrapping the result so you don&#39;t have to call it manually. The above can then be further reduced into</p><pre><code class="language-julia">fence = Fence(device)
fence_signaled = Fence(device, flags=VK_FENCE_CREATE_SIGNALED_BIT; allocator=my_allocator)</code></pre><p>When multiple info structures are requested, only the main one is exposed</p><pre><code class="language-julia"># the ApplicationInfo has to be provided manually
instance = Instance([], []; application_info = ApplicationInfo(...))
...
# the array of DeviceQueueCreateInfo has to be provided manually
device = Device(physical_device, [DeviceQueueCreateInfo(0, [1.0])], [], [])</code></pre><p>When multiple handles are constructed at the same time, no additional constructor is defined and you need to call the create_* function manually</p><pre><code class="language-julia">pipelines = unwrap(create_graphics_pipelines(device, [GraphicsPipelineCreateInfo(...)]))
command_buffers = unwrap(allocate_command_buffers(device, CommandBufferAllocateInfo(
                                           command_pool, VK_COMMAND_BUFFER_LEVEL_PRIMARY, 3)))</code></pre><h3 id="Parent-handle-access"><a class="docs-heading-anchor" href="#Parent-handle-access">Parent handle access</a><a id="Parent-handle-access-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-handle-access" title="Permalink"></a></h3><p>Handles store their parent handle if they have one. This removes the need to have giant structures or global variables to store your handles. You can, e.g., just carry a <code>Pipeline</code> around and access its <code>device</code> field whenever you like, and the <code>physical_device</code> field of this device and so on until you reach the instance that has no parent. Therefore, you won&#39;t need to pass around all the other parent handles.</p><p>It facilitates composability of Vulkan code, that is traditionally very hard because of these giant structures that are often found in applications.</p><h2 id="Bitmask-flags"><a class="docs-heading-anchor" href="#Bitmask-flags">Bitmask flags</a><a id="Bitmask-flags-1"></a><a class="docs-heading-anchor-permalink" href="#Bitmask-flags" title="Permalink"></a></h2><p>In Vulkan, the value of some flags carry meaning through a bitmask structure. Bitmasks define bit values which they can be a composition of (using bitwise <em>and</em>, <em>or</em>, and <em>xor</em> operations). However, the associated flag type is defined as a <code>UInt32</code>, which allows any value to be passed in as a flag. This opens up the door to incorrect usage that may be hard to debug. To circumvent that, every bitmask flag now has one associated type which prevents combinations with flags of other bitmask types.</p><p>For example, consider the vanilla <code>VkSampleCountFlags</code> type (alias for <code>UInt32</code>) with bits defined via the enumerated type <code>VkSampleCountFlagBits</code>:</p><pre><code class="language-julia-repl">julia&gt; using Vulkan.core

julia&gt; VK_SAMPLE_COUNT_1_BIT isa VkSampleCountFlagBits
true

julia&gt; VK_SAMPLE_COUNT_1_BIT === VkSampleCountFlagBits(1)
true

julia&gt; VK_SAMPLE_COUNT_1_BIT === VkSampleCountFlags(1)
false

julia&gt; VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT === VkSampleCountFlags(3)
true

julia&gt; VK_SAMPLE_COUNT_1_BIT &amp; VK_SAMPLE_COUNT_2_BIT === VkSampleCountFlags(0)
true

julia&gt; VK_SAMPLE_COUNT_1_BIT &amp; VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR === VkSampleCountFlags(1)
true</code></pre><p>Those two types are combined into one <code>SampleCountFlag</code>:</p><pre><code class="language-julia-repl">julia&gt; SampleCountFlag &lt;: BitMask
true

julia&gt; SurfaceTransformFlagKHR &lt;: BitMask # another bitmask flag
true

julia&gt; SAMPLE_COUNT_1_BIT | SAMPLE_COUNT_2_BIT === SampleCountFlag(3)
true

julia&gt; SAMPLE_COUNT_1_BIT &amp; SAMPLE_COUNT_2_BIT === SampleCountFlag(0)
true

julia&gt; SAMPLE_COUNT_1_BIT &amp; SURFACE_TRANSFORM_IDENTITY_BIT_KHR
ERROR: Bitwise operation not allowed between incompatible bitmasks &#39;SampleCountFlag&#39;, &#39;SurfaceTransformFlagKHR&#39;

julia&gt; UInt32(typemax(SampleCountFlag)) === UInt32(vk.VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM)
true</code></pre><p>All functions that were expecting a <code>VkSampleCountFlags</code> (<code>UInt32</code>) value will have their wrapped versions expect a value of type <code>SampleCountFlag</code>. Note also that the <code>*FLAG_BITS_MAX_ENUM</code> fields are removed. This value is the same for all enums and can be accessed via <code>typemax(T)</code> where <code>T</code> is a <code>BitMask</code> (e.g. <code>SampleCountFlag</code>).</p><h1 id="preferences"><a class="docs-heading-anchor" href="#preferences">Preferences</a><a id="preferences-1"></a><a class="docs-heading-anchor-permalink" href="#preferences" title="Permalink"></a></h1><p>Some of the above features may have configurable options that can be set via <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Preferences require running at least Julia 1.6. For earlier versions, these options are not customizable, and will have their default values.</p></div></div><table><tr><th style="text-align: center">Preference</th><th style="text-align: center">Description</th><th style="text-align: center">Default</th></tr><tr><td style="text-align: center"><code>LOG_DESTRUCTION</code></td><td style="text-align: center">Log the destruction of Vulkan handles</td><td style="text-align: center"><code>&quot;false&quot;</code></td></tr></table></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../design/">« Design</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 31 March 2021 15:41">Wednesday 31 March 2021</span>. Using Julia version 1.6.0-rc1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
